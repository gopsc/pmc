#pragma once
#include "中文化.hpp"
#include "异常.hpp"
命名空间 中文标准 {
模板 <类型名 类型1>
类 向量{
公开的:
   
    /* 注意：当长度单位为0时，内部指针是空的 */
    向量() {
        对象->指针 = 空指针;
        对象->容量 = 0;
    }
    /* 专门用于处理花括号初始化列表 */
    向量(常量 std::initializer_list<类型1>& init = {}) {
        对象->指针 = 新建 类型1[init.size()] {空的};
        对象->容量 = init.size();
        长度单位 计数 = 0;
        计次循环(适应 & 东西: init) {
            对象->指针[计数++] = 东西;
        }
    }

    ~向量() {
        删除 对象->指针;
        对象->指针 = 空指针;
        对象->容量 = 0;
    }
    /*----------访问器----------*/
    长度单位 取容量() {
        返回 对象->容量;
    }

    布尔 是否为空() {
        返回 对象->容量 等于 0;
    }

    /*--------运算符重载--------*/
    向量& _取下标重载( 常量 长度单位 下标 ) {
        如果(下标 < 0 或 下标 >= 对象->容量)
            抛出异常 下标越界{"向量", 对象->容量, 下标};
        返回 对象->指针[下标];
    }

    /*--------可范围遍历--------*/
    类型1* _开始() {
        返回 对象->指针;
    }

    类型1* _结束() {
        返回 对象->指针 + 对象->容量;
    }

    /*----------变异器----------*/
    空类型 插入元素(常量 长度单位 位置, 常量 向量& 媒介) {

        /* 越界检查 */
        如果(位置 < 0 或 位置 > 对象->容量)
            抛出异常 下标越界{"向量元素插入", 对象->容量+1, 位置};

        适应 长度 = 取容量();
        适应 新的 = 新建 类型1[长度 + 1] { 空的 };

        /* 插入位置之前 */
        计次循环(适应 计数 = 0; 计数 < 位置; ++计数)
            新的[计数] = 对象->指针[计数];

        /* 执行插入 */
        新的[位置] = 媒介;

        /* 插入位置之后 */
        计次循环(适应 计数 = 位置 + 1; 计数 <= 长度; ++计数)
            新的[计数] = 对象->指针[计数 - 1];

        如果(对象->指针) 删除[] 对象->指针; /* 可能为空 */
        对象->指针 = 新的;
    }

    空类型 追加元素(常量 向量& 媒介) {
        适应 长度 = 取容量();
        适应 新的 = 新建 类型1[长度 +1] {空的};
        计次循环(适应 计数 = 0; 计数 < 长度; ++计数)
            新的[计数] = 对象->指针[计数];
        新的[长度] = 媒介;
        如果(对象->指针) 删除[] 指针; /* 可能为空 */
        对象->指针 = 新的;
    }

    空类型 删除元素(常量 长度单位 位置) {

        /* 越界检查 */
        如果(位置 < 0 或 位置 >= 对象->容量)
            抛出异常 下标越界{"向量元素插入", 对象->容量 + 1, 位置};

        适应 长度 = 取容量();
        适应 新的 = (长度 等于 1) 
            ? 空指针 : 新建 类型1[长度 - 1] { 空的 };

        /* 目标位置之前 */
        计次循环(适应 计数 = 0; 计数 < 位置; ++计数)
            新的[计数] = 对象->指针[计数];

        /* 目标位置之后 */
        计次循环(适应 计数 = 位置; 计数 < 长度; ++计数)
            新的[计数] = 对象->指针[计数 + 1];

        删除[] 对象->指针;
        对象->指针 = 新的;
    }



    /*----------------*/
    //类 迭代器{
    //公开的:
    //    迭代器(常量 std::vector<类型1>::iterator& it) {
    //        this->it = it;
    //    }
    //私有的:
    //    std::vector<类型1>::iterator it;
    //};
    /*----------------*/


私有的:
    类型1 *指针;
    长度单位 容量;
};
}